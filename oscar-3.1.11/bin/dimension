#!/bin/sh


## Copyright (c) 2003-2013 Tissoires Jean-Fran√ßois & Benjamin, jftissoires@gmail.com
## Cdrom Outil Syst√®me Complet d'Assistance R√©seau: OSCAR
## Ce programme est sous Licence Publique G√©n√©rale GNU publi√©e par la Free Software Foundation.

PATH="/usr/share/oscar/bin:$PATH"

#-----------------------------------------------------------------------------------------------------
boite_demande_cle_usb()
{
runme prepare_fichier_temptaille
rm -f /tmp/bozo

        # couleurs
	runme colorier_selection_info
 	cp -f /tmp/couleurs_info /tmp/bozo
 	rm -f /tmp/couleurs_info

	DIALOGRC="/etc/dialogmenu_bloque" dialog --colors \
	--backtitle "`cat /etc/banniere_oscar`" \
	--cancel-label "Annuler" --ok-label "Sur partition affich√©e" \
	--extra-button --extra-label "Autre connecteur USB" \
	--title " Modifier la taille d'une partition sans perdre les donn√©es " \
	--menu "\n\Zn`cat /tmp/bozo`" 0 0 0 \
	"" " " \
	"" "\Z1   Sauvegardez d'abord la partition √† modifier, ce logiciel n'est pas garanti ! " \
	"" "\Z2   Vous pouvez aussi modifier la taille sur un autre connecteur \Z1USB\Z2:  " \
	"" "\Z2   Branchez ce connecteur \Z1USB\Z2 puis s√©lectionnez \Zb\Z4< Autre connecteur USB >  " \
	"" ""
      case $? in
	    0)	rm -f /tmp/bozo	# sur partition vue
		return;;
	    1)	rm -f /tmp/bozo
	        exit;;
	    3)	rm -f /tmp/bozo	# sur autre cle USB
		echo
		runme lecture_connecteur_usb
		boite_demande_cle_usb
		return;;
			
	    255) rm -f /tmp/bozo
		exit;;
	esac
}
#----------------------------------------------------------------------------------------------------
boite_partition_modifiee() # selectionner seulement les partitions possibles
{
	# supprimer du choix les partitions non redimensionnables: XFS,JFS ??? :grep -v "WXFS'd"
	runme prepare_fichier_temptaille
	rm -f /tmp/bozo
	egrep -e "^/dev" /tmp/fichier_disque_dur | \
	perl -pi -e 's/\*//g;  s/\+/ /g; s/\-/ /g; s/  /:/g; s/:+/:/g;' | \
	awk 'BEGIN { FS=" " } { printf ("%0s %15s %25s\n","\""$1"\" \"",$2,$3"\" \\")}' >> /tmp/bozo

	runme boite_selection_bozo
}
#-----------------------------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------
demander_partition_a_modifier()
{
	rm -f /tmp/menu_titre
	rm -f /tmp/menu_texte
	rm -f /tmp/fichierquestion

	echo " Partition √† redimensionner " > /tmp/menu_titre
	echo "" > /tmp/menu_texte
	echo "\n\Zb\Z4S√©lectionnez la partition √†\Zb\Z1 modifier \Zn:\n\n " > /tmp/fichierquestion
	echo "\n\n\Zn\Z4    partition         taille Mo                type" >> /tmp/fichierquestion
	boite_partition_modifiee
	if ( test -e /tmp/sortir )
	        then
	        rm -f /tmp/sortir
	        exit
	fi
	
	rm -f /tmp/menu_titre
	rm -f /tmp/menu_texte
	rm -f /tmp/fichierquestion

	perl -pi -e 's/\/dev\///g;' /tmp/tempfile
	reponse=`cat /tmp/tempfile`	# hdaiii
	rm -f /tmp/tempfile
}
#-----------------------------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------
prendre_valeur_debut_partition()	# prendre la valeur de debut de la partition:
{
	sfdisk -l -uB /dev/$disque 2>/dev/null | grep -i "^\/dev\/$disque$numero_partition" | grep -v "dev\/dm-" | \
	perl -pi -e 's/\*//g; s/\+//g; s/\-//g; s/ /:/g; s/::::/:/g; s/:::/:/g; s/::/:/g; s/::/:/g;' | \
	cut -d":" -f2 > /tmp/debut_partition_SP
	debut_partition_SP=$[`cat /tmp/debut_partition_SP`*1000000/1024] # valeur en octet
	echo "$debut_partition_SP" > /tmp/debut_partition_SP
}
#-----------------------------------------------------------------------------------------------------
prendre_valeur_fin_partition()	# prendre la valeur de fin de la partition:
{
	sfdisk -l -uB /dev/$disque 2>/dev/null | grep -i "^\/dev\/$disque$numero_partition" | grep -v "dev\/dm-" | \
	perl -pi -e 's/\*//g; s/\+//g; s/\-//g; s/ /:/g; s/::::/:/g; s/:::/:/g; s/::/:/g; s/::/:/g;' | \
	cut -d":" -f3 > /tmp/fin_partition_SP
	fin_partition_SP=$[`cat /tmp/fin_partition_SP`*1000000/1024] # valeur en octet
	echo "$fin_partition_SP" > /tmp/fin_partition_SP
}
#-----------------------------------------------------------------------------------------------------
cherche_valeurs_disque()
{
fdisk -lu /dev/$disque 2>/dev/null | grep -i "^Disk \/dev\/" | grep -v "dev\/dm-" | \
cut -d"," -f2 | cut -d" " -f2 > /tmp/taille_disque_octet
taille_disque_octet=`cat /tmp/taille_disque_octet`
taille_disque_octet=$[$taille_disque_octet * 1000000 / 1048576 ] # 1048576 d˚e √† fsdisk -lu
rm -f /tmp/taille_disque_octet
}
#-----------------------------------------------------------------------------------------------------
etude_partitions_etendues()
{
	# prendre la premiere ligne du fichier des partitions
	        #lire la premiere valeur indice partition etendue
	        cut -d";" -f1 /tmp/fichiertemp1 > /tmp/fichiertemp
    		# remplacer cette valeur par rien dans /tmp/fichiertemp1
    		echo "perl -pi -e 's/`cat /tmp/fichiertemp`;//g;' /tmp/fichiertemp1" > /tmp/exec_nom
	        chmod +x /tmp/exec_nom
    		/tmp/exec_nom
		rm -f /tmp/exec_nom

		# prendre la partition indice etendue
		numero_partition=`cat /tmp/fichiertemp`
	        if [ "$numero_partition" = "" ] || [ "$numero_partition" = " " ] # test fin
    		then
            	    rm -f /tmp/fichiertemp1
    		    rm -f /tmp/fichiertemp
	    	    return
	        fi

		# test si dans la partition etendue
		
		prendre_valeur_debut_partition
		valeur_debut_etendue=`cat /tmp/debut_partition_SP`	# en octet
		rm -f /tmp/debut_partition_SP
		prendre_valeur_fin_partition
		valeur_fin_etendue=`cat /tmp/fin_partition_SP`
		rm -f /tmp/fin_partition_SP

		resultat_debut=$[$debut_partition - $valeur_debut_etendue]
		resultat_fin=$[$valeur_fin_etendue - $fin_partition]

		signe_negatif_debut=`expr substr $resultat_debut 1 1`
		signe_negatif_fin=`expr substr $resultat_fin 1 1`

		valeur_finale_etendue=
		if ! [ "$signe_negatif_debut" = "-" ] || [ "$signe_negatif_debut" = "0" ]
		then
			if ! [ "$signe_negatif_fin" = "-" ] || [ "$signe_negatif_fin" = "0" ]
			then # dans la partition etendue
			    # prendre la valeur maxi : fin d'etendue:
			    numero_partition_etendue=$numero_partition
			    if ! [ "$derniere_partition" = "oui" ]	# ce n'est pas la derniere partition
			    then
				    valeur_finale_etendue=$valeur_fin_etendue
			    fi
			    # si c'est la derniere partition conserver valeur_finale: valeur_fin_disque
	            	    rm -f /tmp/fichiertemp1
        		    rm -f /tmp/fichiertemp
			    return
			fi
		fi
    		etude_partitions_etendues
}
#-----------------------------------------------------------------------------------------------------
nettoyer_tmp_fin()
{
		rm -f /tmp/tempfile
#		rm -f /tmp/valeur_unite_disque_octet
		rm -f /tmp/nouvelle_taille
		rm -f /tmp/ligne_numero_hd
		rm -f /tmp/ligne_numero_hd_parted
		rm -f /tmp/partition
		rm -f /tmp/tempfile1
		rm -f /tmp/fichiertemp
		rm -f /tmp/fichiertemp1
}
#-----------------------------------------------------------------------------------------------------
demande_taille_partition()
{
	taille_maxi_Mega=$[$taille_maxi/1000000]
	taille_mini_Mega=$[$taille_mini/1000000+1]
        DIALOGRC="/etc/dialogrc" dialog --colors \
        --backtitle "`cat /etc/banniere_oscar`" \
        --cancel-label "Annuler"  --title " Nouvelle taille de la partition " \
        --inputbox "\n\n \Zb\Z4 Donnez la nouvelle taille (\Znsans unit√©\Zb\Z4) de la partition \Z2$disque$numero_hd \n \
	\n\n  \Zn\Zb\Z4Cette taille doit √™tre comprise entre \Z3$taille_mini_Mega\Z4 Mo et \Z3$taille_maxi_Mega\Z4 Mo\Zn \n" 14 74 2>/tmp/tempfile
     case $? in
            0)  nouvelle_taille=`cat /tmp/tempfile`
	        test_bornes=$[$taille_maxi_Mega - $nouvelle_taille]
	        signe_negatif=`expr substr $test_bornes 1 1`
		if [ "$signe_negatif" = "-" ] 
		then # nouvelle_taille est plus grande que taille maxi
		    demande_taille_partition
		else
		    test_bornes=$[$nouvelle_taille - $taille_mini_Mega]
		    signe_negatif=`expr substr $test_bornes 1 1`
		    if [ "$signe_negatif" = "-" ] 
		    then # nouvelle_taille est plus petite que taille mini
			demande_taille_partition
		    fi
		fi
        	;;
            1)  nettoyer_tmp_fin
		exit
		;;
            255) nettoyer_tmp_fin
		exit
		;;
    esac
nouvelle_taille_octet=$[$nouvelle_taille*1000000]	# en octet
}
#-----------------------------------------------------------------------------------------------------
caracteristiques_partition()	# valeurs mini et maxi disponibles pour linux et vfat
{
# parted /dev/$reponse print

    numero_partition=$numero_hd
    prendre_valeur_debut_partition
    debut_partition=`cat /tmp/debut_partition_SP`
    rm -f /tmp/debut_partition_SP
    prendre_valeur_fin_partition
    fin_partition=`cat /tmp/fin_partition_SP`
    rm -f /tmp/fin_partition_SP
 
    taille_partition=$[$fin_partition - $debut_partition]
    taille_maxi=$taille_partition

    if ! ( test -e /mnt/$reponse )
    then
	mkdir /mnt/$reponse
    fi

    echo "$reponse" > /tmp/monter_partition
    runme autoriser_monter_partition_oscar_montage
    nombpart=`cat /tmp/nombpart`
    if [ "$nombpart" = 0 ]
    then
        mount /dev/$reponse /mnt/$reponse
    fi

	echo "`df /mnt/$reponse | grep "$reponse"`" > /tmp/toutes_les_valeurs
	grep -i "dev" /tmp/toutes_les_valeurs > /tmp/toutes_les_valeurs1
	
	valeur=`awk '{print$3}' /tmp/toutes_les_valeurs1`
		
	rm -f /tmp/toutes_les_valeurs
	rm -f /tmp/toutes_les_valeurs1

    	#	valeur=`df /mnt/$reponse | grep "$reponse" | awk '{print$3}'`
    	
    taille_mini=$[$valeur*1000] # en octet
    umount /mnt/$reponse 2>/dev/null ; sync
}
#-----------------------------------------------------------------------------------------------------
transposer_en_Mega_decimal()	# remplace la valeur en octet en mega avec six d√©cimales
{
	# transposer = XXXXXXXXYYYYYY
valeur_mega=$[$transposer / 1000000]	# en Mo		# XXXXXXXX
decimale_fin=$[$transposer - $valeur_mega * 1000000]	# YYYYYY
decimale_fin=$[$decimale_fin / 1000]			# YYY
sortie_transposer=$valeur_mega.$decimale_fin		# XXXXXXXX.YYY
#sortie_transposer=$valeur_mega
}
#-----------------------------------------------------------------------------------------------------
adresses_debut_fin() # d√©termine les adresses d√©but et fin de la nouvelle partition
{
    cherche_taille_maxi_libre
    demande_taille_partition
	
	adresse_fin_nouvelle=$[$debut_partition + $nouvelle_taille_octet]	# en octet #	# XXXXXXXXYYYYYY
	adresse_fin_Mega=$[$adresse_fin_nouvelle / 1000000]	# en Mo		# XXXXXXXX
	
	transposer=$debut_partition
    	transposer_en_Mega_decimal    			
    	debut_partition_Mega=$sortie_transposer # en Mo decimal XXXXXXX.YYYYYY
}
#-----------------------------------------------------------------------------------------------------
agrandir_partition_etendue_ancien() # si la partition √©tendue existe l'agrandir √©ventuellement
{
	if ! [ "$valeur_finale_etendue" = "" ] # cette partition est dans une partition √©tendue 
	then	# voir s'il faut agrandir aussi cette valeur maxi etendue
	    test_adresse_fin_etendue=$[$adresse_fin_nouvelle - $valeur_finale_etendue]
	    signe_negatif=`expr substr $test_adresse_fin_etendue 1 1`
	    if ! [ "signe_negatif" = "-" ]	# agrandir la partition etendue jusqu'a adresse_fin_nouvelle
	    then	# agrandir partition etendue
	    	transposer=$valeur_debut_etendue
		transposer_en_Mega_decimal    			
		debut_partition_etendue_Mega=$sortie_transposer # en Mo decimal XXXXXXX.YYYYYY

		parted /dev/$disque resize $numero_partition_etendue $debut_partition_etendue_Mega $adresse_fin_Mega  0>/dev/null	    
	    fi
    	fi
}
#-----------------------------------------------------------------------------------------------------
afficher_nouvelles_partitions()
{
	runme prepare_fichier_temptaille
	echo "$disque$numero_hd" > /tmp/fichiertemp1
	echo "perl -pi -e 's/\/dev\/`cat /tmp/fichiertemp1`/\\033[1;31m\/dev\/`cat /tmp/fichiertemp1`\\033[1;m/g;' /tmp/fichier_disque_dur" > /tmp/exec_nom
        chmod +x /tmp/exec_nom
	/tmp/exec_nom
	rm -f /tmp/exec_nom
	cat /tmp/fichier_disque_dur
	rm -f /tmp/fichiertemp1
	rm -f /tmp/fichiertemp
}
#-----------------------------------------------------------------------------------------------------
modifier_partition_ancien()	# sauf NTFS
{
    caracteristiques_partition
    adresses_debut_fin

	test_taille_partition=$[$nouvelle_taille_octet - $taille_partition]
	signe_negatif=`expr substr $test_taille_partition 1 1`
	
#	if ! [ "$signe_negatif" = "-" ] || [ "$signe_negatif" = "0" ]
#	then # nouvelle_taille est plus grande √† la maxi
#	agrandir_partition_etendue # √©ventuellement
#	fi

    DIALOGRC="/etc/dialogmenu_bloque" dialog --colors \
	--backtitle "`cat /etc/banniere_oscar`" \
	--title " Redimension de la partition $reponse " \
	--infobox "\n\n\n\Zb\Z1  Attention: \Z2Cette proc√©dure dure quelques minutes... \n \
	\n\Zb\Z4  Si l'√©cran s'√©teint appuyez alors sur la touche \Z7Ctrl\n \
	\n\Zb\Z2                       Patience...  \n\n" 13 60

#	if [ "$id_type" = "c" ] || [ "$id_type" = "b" ] || [ "$id_type" = "e" ]  # partition vfat
#	then
#	parted /dev/$disque resize $numero_hd $debut_partition_Mega $adresse_fin_Mega  0>/dev/null
#	else	# type linux 83 ou linux-swap
		# copie la table de partition d'origine:
		sfdisk -d /dev/$disque > /tmp/table_partitions.sf 2>/dev/null
		echo "$disque" > /tmp/disque_ntfs
		
		# supprime la partition a modifier:
		parted /dev/$disque rm $numero_hd 1>/dev/null
		# prendre le type de partition:
		prendre_type_partition_numero_hd_parted
		# trouver le type linux: ext2,ext3 et linux-swap
		prendre_type_numero_hd_parted
		# cree la nouvelle partition:
		parted /dev/$disque mkpart $type_partition $type_fs $debut_partition_Mega $adresse_fin_Mega 1>/dev/null
		if ! [ "$?" = "0" ]
		then	# erreur
			echo
			echo -e "\033[1;31m   ATTENTION\033[1;34m, erreur pendant la redimension :\033[1;m"		
			echo
			# metrre la table des partitions d'origine
			sfdisk -f /dev/$disque < /tmp/table_partitions.sf 2>/dev/null
			sleep 2 # obligatoire apr√®s l'installation de la table des partitions
			rm -f /tmp/table_partitions.sf

			afficher_erreur
		fi # fin d'erreur de redimension
#	fi

	afficher_nouvelles_partitions
}
#-----------------------------------------------------------------------------------------------------
modifier_partition()	# sauf NTFS
{
    caracteristiques_partition
    adresses_debut_fin

	# copie la table de partition d'origine:
	sfdisk -d /dev/$disque > /tmp/table_partitions.sf 2>/dev/null
	echo "$disque" > /tmp/disque_ntfs

	test_taille_partition=$[$nouvelle_taille_octet - $taille_partition]
	signe_negatif=`expr substr $test_taille_partition 1 1`
	
#	if ! [ "$signe_negatif" = "-" ] || [ "$signe_negatif" = "0" ]
#	then # nouvelle_taille est plus grande √† la maxi
#	agrandir_partition_etendue # √©ventuellement
#	fi

    DIALOGRC="/etc/dialogmenu_bloque" dialog --colors \
	--backtitle "`cat /etc/banniere_oscar`" \
	--title " Redimension de la partition $reponse " \
	--infobox "\n\n\n\Zb\Z1  Attention: \Z2Cette proc√©dure dure quelques minutes... \n \
	\n\Zb\Z4  Si l'√©cran s'√©teint appuyez alors sur la touche \Z7Ctrl\n \
	\n\Zb\Z2                       Patience...  \n\n" 13 60
	
	parted /dev/$disque resize $numero_hd $debut_partition_Mega $adresse_fin_Mega # 0>/dev/null
	if ! [ "$?" = "0" ]
	then	# erreur
		echo
		echo -e "\033[1;31m   ATTENTION\033[1;34m, erreur pendant la redimension :\033[1;m"		
		echo
		# metrre la table des partitions d'origine
		sfdisk -f /dev/$disque < /tmp/table_partitions.sf 2>/dev/null
		sleep 2 # obligatoire apr√®s l'installation de la table des partitions
		rm -f /tmp/table_partitions.sf

		afficher_erreur
	fi # fin d'erreur de redimension

	afficher_nouvelles_partitions
}
#-----------------------------------------------------------------------------------------------------
caracteristiques_partition_ntfs()	# valeurs mini disponible debut et fin de partition
{
    # ntfsresize -i /dev/$reponse	# donne l'information sur les tailles

    ntfsresize -i /dev/$reponse | grep -i "You might resize at" | \
    cut -d" " -f5 > /tmp/tempfile
    taille_mini=`cat /tmp/tempfile`

    numero_partition=$numero_hd
    prendre_valeur_debut_partition
    debut_partition=`cat /tmp/debut_partition_SP`	# en octet
    rm -f /tmp/debut_partition_SP
    prendre_valeur_fin_partition
    fin_partition=`cat /tmp/fin_partition_SP`		# en octet
    rm -f /tmp/fin_partition_SP
    
    taille_partition=$[$fin_partition - $debut_partition]	# en octet
    taille_maxi=$taille_partition
    
     ntfsresize -i /dev/$reponse | grep -i "Current device size:" | \
     cut -d"(" -f2 | cut -d")" -f1 > /tmp/tempfile	 		# XX MB
     cut -d" " -f2 /tmp/tempfile > /tmp/tempfile1
     unite_maxi_ntfs=`cut -c1 /tmp/tempfile1`			# M

     ntfsresize -i /dev/$reponse | grep -i "Space in use" | \
     cut -d":" -f2 | cut -d" " -f2-3 > /tmp/tempfile			# YY MB
     cut -d" " -f2 /tmp/tempfile > /tmp/tempfile1
     unite_mini=`cut -c1 /tmp/tempfile1`				# M

     rm -f /tmp/tempfile
     rm -f /tmp/tempfile1

	    	    
        if [ "$unite_mini" = "" ] || [ "$unite_maxi_ntfs" = "" ] # controle de lecture ntfs
	then
	    echo
            echo -e "\033[1;34m   Vous devez \033[1;31mred√©marrer\033[1;34m le poste sous\033[1;31m Windows\033[1;m"
	    echo
	    read p
	    exit
	fi		
}
#-----------------------------------------------------------------------------------------------------
verifie_si_derniere_partition()
{
	parted /dev/$disque print | grep -i "^$numero_hd" | \
	perl -pi -e 's/\*//g; s/ /:/g; s/::::/:/g; s/:::/:/g; s/::/:/g; s/::/:/g;' > /tmp/ligne_numero_hd_parted
	# fichier ligne_numero_hd_parted  7:20GB:20GB:100MB:logical:ntfs:
	
	fdisk -l /dev/$disque 2>/dev/null | grep -i "^\/dev\/$reponse" | grep -v "dev\/dm-" | \
	perl -pi -e 's/\*//g; s/ /:/g; s/::::/:/g; s/:::/:/g; s/::/:/g; s/::/:/g;' > /tmp/ligne_numero_hd
	# fichier ligne_numero_hd_parted  


	numero_hd_suivant=$[$numero_hd+1]
    	parted /dev/$disque print | grep -ci "^$numero_hd_suivant"  > /tmp/tempfile
	test_partition_suivante=`cat /tmp/tempfile`	# valeur 0 si rien apres

	if ! [ "$test_partition_suivante" = "0" ]
	then	# Il existe une autre partition
		numero_partition=$numero_hd_suivant
		prendre_valeur_debut_partition
		debut_partition_suivant=`cat /tmp/debut_partition_SP`	# en octet
		rm -f /tmp/debut_partition_SP
		
		prendre_valeur_fin_partition
		fin_partition_suivant=`cat /tmp/fin_partition_SP`
		rm -f /tmp/fin_partition_SP

    		# la taille maxi a proposer:

		valeur_finale=$debut_partition_suivant
		taille_maxi=$[$debut_partition_suivant - $debut_partition]

	else
		# prendre la valeur totale du disque
    		# la taille maxi a proposer:
		taille_maxi=$[$taille_disque_octet - $debut_partition]
	fi
}
#-----------------------------------------------------------------------------------------------------
verifie_si_dans_partition_etendue()
{
    	parted /dev/$disque print | grep -ci "extended"  > /tmp/tempfile
	nbr_partitions_etendues=`cat /tmp/tempfile`
	rm -f /tmp/tempfile

	if ! [ "$nbr_partitions_etendues" = "0" ]
	then	#Il existe des partitions etendues
	    # faire un fichier des partitions etendues:

	    # faire le fichier des numeros des partitions etendues:
	    parted /dev/$disque print | grep -i "extended"  > /tmp/fichiertemp
	    # remplacer les espaces par ' ; '   :
	    perl -pi -e 's/ / ; /g;' /tmp/fichiertemp
	    # prendre les numeros des partitions situes a la premiere colonne :
	    echo `gawk '{ print $1 ";" } ' /tmp/fichiertemp` > /tmp/fichiertemp1    # numero1; numero2; numero3;
	    rm -f /tmp/fichiertemp
	    # supprimer les espaces:
	    perl -pi -e 's/ //g;' /tmp/fichiertemp1    # numero1;numero2;numero3;

	    etude_partitions_etendues
	    if ! [ "$valeur_finale_etendue" = "" ]
	    then	# voir s'il faut prendre cette valeur maxi etendue
		taille_si_etendue=$[$valeur_finale_etendue - $debut_partition]
		resultat=$[$taille_si_etendue - $taille_maxi]
		signe_negatif=`expr substr $resultat 1 1`
		if [ "$signe_negatif" = "-" ]
		then	# taille_si_etendue plus petite a prendre s'ii existe une partition numero_hd_suivant
			if ! [ "$test_partition_suivante" = "0" ]
			then	# Il existe une autre partition
				taille_maxi=$taille_si_etendue	# sinon conserver la taille maxi
			fi
	    	fi
	    fi

	fi	# fin de partitions etendues avec taille_maxi=taille maxi √©tendue
}
#-----------------------------------------------------------------------------------------------------
cherche_taille_maxi_libre()
{
	#   parted /dev/$disque print # donne l'information sur le type (de depart) de la partition
	verifie_si_derniere_partition
	verifie_si_dans_partition_etendue
}
#-----------------------------------------------------------------------------------------------------
prendre_type_partition_numero_hd_parted()
{
    # fichier ligne_numero_hd_parted 7:20GB:20GB:100MB:logical:ntfs ou 7:20GB:20GB:logical:ntfs

#    cut -d":" -f5 /tmp/ligne_numero_hd_parted > /tmp/tempfile	# prendre 'logical'
#    type_partition=`cat /tmp/tempfile`

    	grep -ci "primary" /tmp/ligne_numero_hd_parted > /tmp/tempfile
	test_type=`cat /tmp/tempfile`	# valeur 0 si rien apres
	if [ "$test_type" = "1" ]
	then	#  primary
	    type_partition="primary"
	else
	    grep -ci "logical" /tmp/ligne_numero_hd_parted > /tmp/tempfile
	    test_type=`cat /tmp/tempfile`	# valeur 0 si rien apres
	    if [ "$test_type" = "1" ]
	    then	# logical
		type_partition="logical"
	    else
		grep -ci "extended" /tmp/ligne_numero_hd_parted > /tmp/tempfile
		test_type=`cat /tmp/tempfile`	# valeur 0 si rien apres
		if [ "$test_type" = "1" ]
		then	# extended
		    type_partition="extended"
		fi    
	    fi
	fi
rm -f /tmp/tempfile
}
#-----------------------------------------------------------------------------------------------------
prendre_type_numero_hd_parted()
{
    # fichier ligne_numero_hd_parted 7:20GB:20GB:100MB:logical:ext3 ou 7:20GB:20GB:logical:ext3

grep -ci "ext3" /tmp/ligne_numero_hd_parted > /tmp/tempfile
test_type=`cat /tmp/tempfile`	# valeur 0 si rien apres
if [ "$test_type" = "1" ]
then	# ext3
    type_fs="ext3"
else
	grep -ci "ext4" /tmp/ligne_numero_hd_parted > /tmp/tempfile
	test_type=`cat /tmp/tempfile`	# valeur 0 si rien apres
	if [ "$test_type" = "1" ]
	then	# ext4
	    type_fs="ext4"
	else
	    grep -ci "fat32" /tmp/ligne_numero_hd_parted > /tmp/tempfile
	    test_type=`cat /tmp/tempfile`	# valeur 0 si rien apres
	    if [ "$test_type" = "1" ]
	    then	# fat32
		type_fs="fat32"
	    else
		grep -ci "linux-swap" /tmp/ligne_numero_hd_parted > /tmp/tempfile
		test_type=`cat /tmp/tempfile`	# valeur 0 si rien apres
		if [ "$test_type" = "1" ]
		then	# linux-swap
			type_fs="linux-swap"
		else
			grep -ci "extended" /tmp/ligne_numero_hd_parted > /tmp/tempfile
			test_type=`cat /tmp/tempfile`	# valeur 0 si rien apres
			if [ "$test_type" = "1" ]
			then	# extended
		    		type_fs="extended"
			else	# reste fat16
		    		type_fs=""	 # fat16 rien 
			fi
		fi
	    fi
	fi
fi
rm -f /tmp/tempfile
}
#-----------------------------------------------------------------------------------------------------
afficher_erreur()
{
	echo
	echo -e "\033[1;31m   ATTENTION\033[1;34m, erreur pendant la redimension :\033[1;m"		
	echo
	echo -e "\033[1;33m   OSCAR\033[1;m a remis la \033[1;34mtable des partitions\033[1;m d'origine ..."
	echo
	nettoyer_tmp_fin
	# afficher les anciennes partitions :
	echo "$disque$numero_hd" > /tmp/partition
	/usr/share/oscar/bin/runme prepare_fichier_temptaille
	echo "perl -pi -e 's/\/dev\/`cat /tmp/partition`/\\033[1;31m\/dev\/`cat /tmp/partition`\\033[1;m/g;' /tmp/fichier_disque_dur" > /tmp/exec_nom
	chmod +x /tmp/exec_nom
	/tmp/exec_nom
	rm -f /tmp/exec_nom
	cat /tmp/fichier_disque_dur
	rm -f /tmp/partition
	exit
}
#-----------------------------------------------------------------------------------------------------
modifier_partition_ntfs()
{
    caracteristiques_partition_ntfs
    adresses_debut_fin	        
	
    test_taille_partition=$[$nouvelle_taille_octet - $taille_partition]
    signe_negatif=`expr substr $test_taille_partition 1 1`

	if [ "$signe_negatif" = "-" ] || [ "$signe_negatif" = "0" ]
	then # nouvelle_taille est plus petite ou egale √† la maxi ntfs

		# modifier au format ntfsresize
		echo "$nouvelle_taille" > /tmp/nouvelle_taille
		# pour remettre au format ntfsresize
		ntfsresize -s `cat /tmp/nouvelle_taille`M -vfb /dev/$disque$numero_hd

		if [ "$?" = "0" ]
		then	# pas d'erreur"
			# supprime la partition a modifier:
			parted /dev/$disque rm $numero_hd # 1>/dev/null

			# prendre le type de partition: logical etendue ou primary
			prendre_type_partition_numero_hd_parted
		
			# cree la nouvelle partition:

			parted /dev/$disque mkpart $type_partition ntfs $debut_partition_Mega $adresse_fin_Mega 1>/dev/null

		else # erreur de redimension
			afficher_erreur
		fi
	else	 # nouvelle_taille est plus grande a la maxi ntfs
	    
		# copie la table de partition d'origine:
		sfdisk -d /dev/$disque > /tmp/table_partitions.sf 2>/dev/null
		echo "$disque" > /tmp/disque_ntfs

		#agrandir aussi la partition √©tendue avec :valeur_finale_etendue si dans √©tendue
	#	agrandir_partition_etendue # √©ventuellement
		
		# supprime la partition a modifier:
		parted /dev/$disque rm $numero_hd 1>/dev/null
		# prendre le type de partition:
		prendre_type_partition_numero_hd_parted

		# cree la nouvelle partition:
		parted /dev/$disque mkpart $type_partition ntfs $debut_partition_Mega $adresse_fin_Mega 1>/dev/null

		echo "$nouvelle_taille" > /tmp/nouvelle_taille

		# pour remettre au format ntfsresize lance par runme ou menu_disque		
		echo "ntfsresize -s `cat /tmp/nouvelle_taille`M -vfb /dev/$disque$numero_hd
		echo \"\$?\" > /tmp/erreur" > /tmp/augmenter
		chmod +x /tmp/augmenter
		nettoyer_tmp_fin
			
	# a mettre sur le disque dans /bin	# /bin/ntfs_oscar
	
		echo "$disque$numero_hd" > /tmp/partition
################### 7 lignes √† supprimer si nouveau noyau
		echo
		echo -e "\033[1;31m   ATTENTION\033[1;34m, pour ne pas perdre vos donn√©es :\033[1;m"		
		echo		    
		echo -e "\033[1;34m   Vous devez maintenant appuyer sur la touche \033[1;37mEntrer \033[1;m"
		echo -e "\033[1;34m   puis lancez la commande \033[1;37mntfs_oscar\033[1;34m au clavier ...\033[1;m "
		echo
		read p
###################
#		ntfs_oscar	# si cela ne marche pas remettre les 7 lignes pr√©c√©dentes et lancer ntfs_oscar au clavier
###################
		exit
		# pour ntfs_oscar

	fi

	afficher_nouvelles_partitions
	echo 
	echo -e "\033[1;34m   Maintenant le poste doit\033[1;31m red√©marrer\033[1;34m sous\033[1;31m Windows\033[1;34m !\033[1;m"
	echo
	echo -e "\033[1;34m   Appuyez sur la touche \033[1;37mEntrer \033[1;34mpour red√©marrer ...\033[1;m"
	read p
	echo
	echo
	reboot
	sleep 3

	# fin  partition ntfs
}
#-----------------------------------------------------------------------------------------------------
#-----------------------------------------------------------------------------------------------------
#		Redimensionne une partition types possibles: ntfs, ext2/3 fat32 reiserfs reiser4
#-----------------------------------------------------------------------------------------------------
#
boite_demande_cle_usb
demander_partition_a_modifier

	# d√©monter √©ventuellement la partition √† modifier :
	echo "$reponse" > /tmp/monter_partition
	runme autoriser_monter_partition_oscar_montage
	nombpart=`cat /tmp/nombpart`
	rm -f cat /tmp/nombpart
	if ! [ "$nombpart" = 0 ]
	then
		umount /dev/$reponse 1>/dev/null 2>/dev/null ; sync
		if ! [ "$?" = "0" ]
		then	# erreur
			echo
			echo -e "\033[1;31m   IMPOSSIBLE\033[1;34m, la partition \033[1;32m$reponse\033[1;34m est utilis√©e ...\033[1;m"
			echo
			exit
		fi
	fi

# trouver le syst√®me de fichier:

        numero_hd=`expr substr $reponse 4 3`
        disque=`expr substr $reponse 1 3`       #hda
	cherche_valeurs_disque

        # id_type=`sfdisk /dev/$disque -c $numero_hd 2>/dev/null` # 1>/dev/null 2>/dev/null
	grep -i $reponse /tmp/fichier_disque_dur | grep -ci ntfs > /tmp/nb_partition_ntfs
	nb_partition_ntfs=`cat /tmp/nb_partition_ntfs`
	rm -f /tmp/nb_partition_ntfs
	if [ "$nb_partition_ntfs" = "1" ] # partition ntfs
	then
		modifier_partition_ntfs
	else	# les autres partitions
	        modifier_partition
	fi